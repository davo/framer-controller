import * as React from "react"
import {
    addPropertyControls,
    ControlType,
    transform,
    motionValue,
    MotionValue,
} from "framer"
import * as lottie from "lottie-web"

interface Props {
    speed: number
    markerId: string
    animation?: string
    progress: number | MotionValue<number>
}

interface State {
    path: string
    progress: MotionValue<number>
    animation?: AnimationItem
}

export const Scrubber = (props: Props) => {
    const ref = React.useRef<HTMLDivElement>()

    const [state, setState] = React.useState<State>({
        path: undefined,
        animation: undefined,
        progress: undefined,
    })

    React.useEffect(() => {
        let path = props.animation
        let progress = props.progress
        if (!path || !path.includes(".json")) return
        const animation = loadAnimation(path)

        if (typeof progress === "number") {
            progress = motionValue(progress)
        }
        const cancel = progress.onChange(v => {
            setAnimationProgress(v, animation)
        })

        setAnimationProgress(progress.get(), animation)

        setState({ ...state, progress, path, animation })

        return cancel
    }, [props.animation, props.progress])

    const loadAnimation = (path: string) => {
        const { animation: animationInState, progress } = state
        const { current: wrapper } = ref

        if (animationInState) {
            animationInState.destroy()
        }

        const animation = lottie.loadAnimation({
            wrapper,
            path,
            animType: "svg",
            loop: false,
            autoplay: false,
        })

        return animation as AnimationItem
    }
    const unloadAnimation = () => {
        const { animation } = state

        animation.destroy()
        setState({
            ...state,
            animation: null,
        })
    }

    const setAnimationProgress = (progress, animation = state.animation) => {
        const frame = Math.floor(
            transform(
                progress * props.speed,
                [0, 1],
                [0, animation.totalFrames - 1]
            )
        )
        animation.goToAndStop(frame, true)
    }

    const { markerId } = props
    const { animation } = state

    return (
        <div style={{ width: "100%", height: "100%" }} ref={ref}>
            {!animation && <DefaultView markerId={markerId} />}
        </div>
    )
}

Scrubber.defaultProps = {
    progress: 0,
    animation: "",
}

addPropertyControls(Scrubber, {
    progress: {
        type: ControlType.Number,
        title: "Progress",
        min: 0,
        max: 0.999,
        step: 0.001,
        defaultValue: 0,
    },
    speed: {
        type: ControlType.Number,
        title: "Speed",
        min: 0,
        max: 0.999,
        step: 0.001,
        defaultValue: 1,
    },
    animation: {
        type: ControlType.File,
        allowedFileTypes: ["json"],
        title: "Animation",
    },
})

// Define some standard CSS for your component
const style: React.CSSProperties = {
    height: "100%",
    display: "flex",
    flexDirection: "column",
    justifyContent: "center",
    color: "#8855FF",
    background: "rgba(136, 85, 255, 0.1)",
    overflow: "hidden",
    fontSize: 8,
}

export const DefaultView: React.SFC<{ markerId: string }> = ({ markerId }) => {
    return (
        <div style={style}>
            <Title heading="markerId" value={markerId} />
            <div
                style={{
                    display: "flex",
                    flexDirection: "column",
                    paddingBottom: 8,
                    maxWidth: 160,
                    width: "100%",
                    margin: "0 auto",
                }}
            >
                <p>
                    This component shows how an animation may be "scrubbed" by
                    using some other value, such as those generated by a
                    ScrollController.
                </p>
                <p>
                    To use with ScrollController, add a Lottie animation file to
                    this component using the Animation property control. (See{" "}
                    <a href="https://www.lottiefiles.com">here</a> for example
                    files). Next, create a Scroll component, connect it to a
                    content Frame, and control it in an overrides file using{" "}
                    <b>ScrollController</b> from the <b>framer-controller</b>{" "}
                    library. In the same file, Override this component's{" "}
                    <b>progress</b> prop with either the controller's progress
                    value, or the progress value of this or any other one of its
                    markers.
                </p>
                <p>
                    See the{" "}
                    <a href="https://framer-controller.netlify.com">
                        framer-controller docs
                    </a>{" "}
                    for more info and examples.
                </p>
            </div>
        </div>
    )
}

const Title: React.SFC<{ heading: string; value: string }> = ({
    heading,
    value,
}) => {
    return (
        <div
            style={{
                display: "flex",
                flexDirection: "row",
                justifyContent: "space-between",
                paddingBottom: 8,
                maxWidth: 96,
                width: "100%",
                margin: "0 auto",
            }}
        >
            <span>
                <b>{heading}</b>
            </span>
            <span style={{ textAlign: "right" }}>{value}</span>
        </div>
    )
}

interface AnimationItem {
    totalFrames: number

    play()

    stop()

    pause()

    // one param speed (1 is normal speed)
    setSpeed(speed: number)

    // one param direction (1 is normal direction)
    setDirection(direction: number)

    // If false, it will respect the original AE fps. If true, it will update as much as possible. (true by default)
    setSubframe(flag: boolean)

    // first param is a numeric value. second param is a boolean that defines time or frames for first param
    goToAndPlay(value: number, isFrame: boolean)

    // first param is a numeric value. second param is a boolean that defines time or frames for first param
    goToAndStop(value: number, isFrame: boolean)

    // first param is a single array or multiple arrays of two values each(fromFrame,toFrame), second param is a boolean for forcing the new segment right away
    playSegments(segments: number[] | number[][], forceFlag: boolean)

    // To destroy and release resources.
    destroy()
}
